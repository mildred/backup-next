#!/bin/bash

driver=:

main() {
    case "$1" in
        backup)
            run backup "$2"
            ;;
        list)
            run list "$2"
            ;;
        restore)
            descriptor="$2"
            shift 2
            args=()
            extract_args "$@"
            run restore "$descriptor" "${args[@]}"
            ;;
        *)
            echo "${0##*/} backup DESCIPTOR"
            echo "${0##*/} restore DESCIPTOR"
            echo "${0##*/} list DESCIPTOR"
            echo "${0##*/} help"
            return 1
            ;;
    esac
}

# READ  $@    : Arguments to extract
# WRITE $args : Array of arguments appearing after -- in $@
extract_args(){
    until [[ $# -le 0 ]] || [[ $1 = -- ]]; do
        shift
    done
    shift
    args=("$@")
}

# READ $driver
# READ $driver_dir
driver(){
    export BACKUP_DIR="$driver_dir"
    export BACKUP_DRIVER_DIR="$(readlink -f $driver)"
    export BACKUP_DRIVER_DIR="${BACKUP_DRIVER_DIR%/*}"
    "$driver" "$@"
}

# READ  $driver_dir    : the location where to find the driver
# READ  $driver        : if different than ":", will recurse parent directories
#                        to find driver
# WRITE $driver        : the driver that was found
# WRITE $driver_dir    : where the driver was found
# WRITE $?             : failure if driver was not found
find_driver(){
    if [[ -e $driver_dir/driver.sh ]]; then
        . "$driver_dir/driver.sh"
        return 0
    elif [[ -x $driver_dir/driver ]]; then
        driver="$driver_dir/driver"
        return 0
    fi
    
    if [[ $driver != : ]]; then
        local old_driver_dir="$driver_dir"
        driver_dir="${driver_dir%/*}"
        if [[ $old_driver_dir != $driver_dir ]]; then
            find_driver
            return $?
        fi
    fi
    
    return 1
}

# READ  $descriptor : the descriptor
# WRITE $type       : the descriptor type
get_type(){
    if [[ -L $descriptor ]] && [[ -d $descriptor ]]; then
        type=link
    elif [[ -d $descriptor ]]; then
        type=dir
    else
        type=${descriptor##*/}
        type=${type##*.}
    fi
}

# READ $1      : the action (backup, list)
# READ $2      : the backup descriptor
# READ $driver : the driver to use. If empty, the descriptor must be a dir
run() {
    local type
    local res=0
    local driver=$driver
    local driver_change=false
    local action="$1"
    local descriptor="$2"
    local driver_dir="$descriptor"
    local Action="$(tr a-z A-Z <<<${action:0:1})${action:1}"
    shift 2
    
    get_type
    
    if [[ $type != dir ]]; then
        driver_dir="${driver_dir%/?*}"
    fi
    if [[ $type = dir ]] || [[ $driver = : ]]; then
        local old_driver_dir="$driver_dir"
        if find_driver; then
            driver init $action || return 1
            driver_change=true
        elif [[ $driver = : ]]; then
            echo "$old_driver_dir: Could not find driver" >&2
            return 1
        fi
    fi
    
    if type "run_$type" >/dev/null 2>&1; then
        "run_$type" "$@"
        let res+=$?
    else
        echo "$descriptor: Unknown type $type" >&2
        let res++
    fi
    
    if [[ $res = 0 ]] && $driver_change; then
        driver commit $action || let res++
    fi

    return $res
}

banner_action(){
    echo -e "$Bold--> $BIGreen$Action $1$Color_Off"
}

run_dir(){
    local res=0
    banner_action "$descriptor/..."
    for f in "$descriptor"/*; do
        [[ ${f##*/} = driver    ]] && continue
        [[ ${f##*/} = driver.sh ]] && continue
        run $action "$f" "$@"
        let res+=$?
    done
    return $res
}

run_link(){
    local link="$(readlink -f "$descriptor")"
    banner_action "$descriptor -> $link"
    driver $action "$link" "$@"
}

run_exec(){
    banner_action "$descriptor (execute)"
    "$descriptor" "$action" "$@"
}

run_sh(){
    banner_action "$descriptor (plug-in)"
    local args=("$@")
    . "$descriptor"
}

run_conf(){ : ; }

# Reset
Color_Off='\e[0m'       # Text Reset

# Regular Colors
Black='\e[0;30m'        # Black
Red='\e[0;31m'          # Red
Green='\e[0;32m'        # Green
Yellow='\e[0;33m'       # Yellow
Blue='\e[0;34m'         # Blue
Purple='\e[0;35m'       # Purple
Cyan='\e[0;36m'         # Cyan
White='\e[0;37m'        # White

# Bold
Bold='\e[1m'            # No Color Change
BBlack='\e[1;30m'       # Black
BRed='\e[1;31m'         # Red
BGreen='\e[1;32m'       # Green
BYellow='\e[1;33m'      # Yellow
BBlue='\e[1;34m'        # Blue
BPurple='\e[1;35m'      # Purple
BCyan='\e[1;36m'        # Cyan
BWhite='\e[1;37m'       # White

# Underline
UBlack='\e[4;30m'       # Black
URed='\e[4;31m'         # Red
UGreen='\e[4;32m'       # Green
UYellow='\e[4;33m'      # Yellow
UBlue='\e[4;34m'        # Blue
UPurple='\e[4;35m'      # Purple
UCyan='\e[4;36m'        # Cyan
UWhite='\e[4;37m'       # White

# Background
On_Black='\e[40m'       # Black
On_Red='\e[41m'         # Red
On_Green='\e[42m'       # Green
On_Yellow='\e[43m'      # Yellow
On_Blue='\e[44m'        # Blue
On_Purple='\e[45m'      # Purple
On_Cyan='\e[46m'        # Cyan
On_White='\e[47m'       # White

# High Intensity
IBlack='\e[0;90m'       # Black
IRed='\e[0;91m'         # Red
IGreen='\e[0;92m'       # Green
IYellow='\e[0;93m'      # Yellow
IBlue='\e[0;94m'        # Blue
IPurple='\e[0;95m'      # Purple
ICyan='\e[0;96m'        # Cyan
IWhite='\e[0;97m'       # White

# Bold High Intensity
BIBlack='\e[1;90m'      # Black
BIRed='\e[1;91m'        # Red
BIGreen='\e[1;92m'      # Green
BIYellow='\e[1;93m'     # Yellow
BIBlue='\e[1;94m'       # Blue
BIPurple='\e[1;95m'     # Purple
BICyan='\e[1;96m'       # Cyan
BIWhite='\e[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\e[0;100m'   # Black
On_IRed='\e[0;101m'     # Red
On_IGreen='\e[0;102m'   # Green
On_IYellow='\e[0;103m'  # Yellow
On_IBlue='\e[0;104m'    # Blue
On_IPurple='\e[0;105m'  # Purple
On_ICyan='\e[0;106m'    # Cyan
On_IWhite='\e[0;107m'   # White

main "$@"
exit $?